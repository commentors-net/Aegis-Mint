using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Windows;
using Microsoft.Win32;
using AegisMint.Core.Models;
using AegisMint.Core.Security;
using AegisMint.Core.Services;
using NBitcoin;
using Nethereum.Util;

namespace AegisMint.RecoverShares;

public partial class MainWindow : Window
{
    private readonly ObservableCollection<ShareViewModel> _shares = new();
    private readonly JsonSerializerOptions _jsonOptions = new(JsonSerializerDefaults.Web)
    {
        PropertyNameCaseInsensitive = true,
        ReadCommentHandling = JsonCommentHandling.Skip,
        AllowTrailingCommas = true
    };

    private readonly ShamirSecretSharingService _shamir = new();
    private ShareSetMetadata? _metadata;

    public MainWindow()
    {
        InitializeComponent();
        SharesList.ItemsSource = _shares;
        UpdateThresholdText();
        UpdateStatus("Load the recovery share JSON files generated by Aegis Mint.", false);
    }

    private void OnBrowseClick(object sender, RoutedEventArgs e)
    {
        var dialog = new OpenFileDialog
        {
            Title = "Select recovery share files",
            Filter = "Aegis share files (*.json)|*.json|All files (*.*)|*.*",
            Multiselect = true,
            CheckFileExists = true
        };

        if (dialog.ShowDialog() == true)
        {
            LoadShares(dialog.FileNames);
        }
    }

    private void OnClearClick(object sender, RoutedEventArgs e)
    {
        _shares.Clear();
        _metadata = null;
        RecoveredMnemonicBox.Clear();
        PrimaryAddressText.Text = "–";
        SecondaryAddressText.Text = "–";
        MnemonicValidationText.Text = string.Empty;
        UpdateThresholdText();
        UpdateStatus("Cleared loaded shares.", false);
    }

    private void LoadShares(IEnumerable<string> files)
    {
        var added = 0;
        var replaced = 0;
        var errors = new List<string>();

        foreach (var file in files.Distinct(StringComparer.OrdinalIgnoreCase))
        {
            try
            {
                var payload = ParseShareFile(file, out var shareLength);

                if (_metadata is null)
                {
                    _metadata = new ShareSetMetadata(
                        payload.TotalShares,
                        payload.Threshold,
                        payload.ClientShareCount,
                        payload.SafekeepingShareCount,
                        payload.Network ?? string.Empty,
                        shareLength);
                }
                else if (!_metadata.IsCompatibleWith(payload, shareLength))
                {
                    errors.Add($"{Path.GetFileName(file)}: metadata mismatch. Expected {_metadata.Description}.");
                    continue;
                }

                var existing = _shares.FirstOrDefault(s => s.ShareId == payload.ShareId);
                if (existing is not null)
                {
                    _shares.Remove(existing);
                    replaced++;
                }

                _shares.Add(new ShareViewModel(file, payload));
                added++;
            }
            catch (Exception ex)
            {
                errors.Add($"{Path.GetFileName(file)}: {ex.Message}");
                Logger.Warning($"Failed to load share file {file}: {ex.Message}");
            }
        }

        UpdateThresholdText();

        if (errors.Count > 0)
        {
            UpdateStatus($"Loaded {added} share(s). {replaced} replaced. Issues: {string.Join("; ", errors)}", true);
        }
        else if (added == 0 && replaced == 0)
        {
            UpdateStatus("No new shares were loaded.", true);
        }
        else
        {
            UpdateStatus($"Loaded {added} share(s){(replaced > 0 ? $" and replaced {replaced}" : string.Empty)}.", false);
        }
    }

    private ShareFilePayload ParseShareFile(string path, out int shareLength)
    {
        var json = File.ReadAllText(path);
        var payload = JsonSerializer.Deserialize<ShareFilePayload>(json, _jsonOptions)
            ?? throw new InvalidOperationException("File did not contain a share payload.");

        if (payload.ShareId <= 0)
        {
            throw new InvalidOperationException("ShareId must be greater than zero.");
        }

        if (payload.Threshold <= 0 || payload.TotalShares <= 0 || payload.Threshold > payload.TotalShares)
        {
            throw new InvalidOperationException("Invalid threshold/total share values.");
        }

        if (string.IsNullOrWhiteSpace(payload.ShareValue))
        {
            throw new InvalidOperationException("Missing share value.");
        }

        var shareBytes = Convert.FromBase64String(payload.ShareValue);
        if (shareBytes.Length == 0)
        {
            throw new InvalidOperationException("Share payload was empty.");
        }

        shareLength = shareBytes.Length;
        return payload;
    }

    private void UpdateThresholdText()
    {
        if (_metadata is null)
        {
            ThresholdText.Text = "Threshold: waiting for shares.";
            RecoverButton.IsEnabled = false;
            return;
        }

        var ready = _shares.Count >= _metadata.Threshold;
        ThresholdText.Text = $"{_metadata.Threshold}-of-{_metadata.TotalShares} needed. Loaded {_shares.Count}.";
        RecoverButton.IsEnabled = ready;
    }

    private void OnRecoverClick(object sender, RoutedEventArgs e)
    {
        try
        {
            if (_metadata is null)
            {
                UpdateStatus("Load at least one share before recovering.", true);
                return;
            }

            if (_shares.Count < _metadata.Threshold)
            {
                UpdateStatus($"Need at least {_metadata.Threshold} shares; only {_shares.Count} loaded.", true);
                return;
            }

            var sharesToUse = _shares
                .OrderBy(s => s.ShareId)
                .Take(_metadata.Threshold)
                .Select(s => new ShamirShare(s.ShareId, s.ShareValue))
                .ToArray();

            var secretBytes = _shamir.Combine(sharesToUse, _metadata.Threshold);
            var mnemonic = Encoding.UTF8.GetString(secretBytes).Trim();
            var normalizedMnemonic = string.Join(" ", mnemonic.Split(' ', StringSplitOptions.RemoveEmptyEntries));

            RecoveredMnemonicBox.Text = normalizedMnemonic;

            var validation = ValidateMnemonic(normalizedMnemonic);
            MnemonicValidationText.Text = validation;

            var primary = TryDeriveAddress(normalizedMnemonic, 0);
            var secondary = TryDeriveAddress(normalizedMnemonic, 1);
            PrimaryAddressText.Text = primary ?? "Unable to derive address";
            SecondaryAddressText.Text = secondary ?? "Unable to derive address";

            UpdateStatus($"Mnemonic recovered using {_metadata.Threshold} of {_metadata.TotalShares} shares.", false);
        }
        catch (Exception ex)
        {
            Logger.Error("Failed to recover mnemonic", ex);
            UpdateStatus($"Recovery failed: {ex.Message}", true);
            MessageBox.Show(this, $"Recovery failed: {ex.Message}", "Recovery error", MessageBoxButton.OK, MessageBoxImage.Error);
        }
    }

    private string ValidateMnemonic(string mnemonic)
    {
        if (string.IsNullOrWhiteSpace(mnemonic))
        {
            return "No mnemonic recovered.";
        }

        var words = mnemonic.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (words.Length is not (12 or 24))
        {
            return $"Warning: expected 12 or 24 words; found {words.Length}.";
        }

        try
        {
            _ = new Mnemonic(mnemonic, Wordlist.English);
            return $"Mnemonic is valid ({words.Length} words).";
        }
        catch (Exception ex)
        {
            Logger.Warning($"Recovered mnemonic failed validation: {ex.Message}");
            return "Warning: mnemonic failed BIP39 validation.";
        }
    }

    private string? TryDeriveAddress(string mnemonic, int index)
    {
        try
        {
            var mn = new Mnemonic(mnemonic, Wordlist.English);
            var seed = mn.DeriveExtKey();
            var path = new KeyPath($"m/44'/60'/0'/0/{index}");
            var key = seed.Derive(path);
            var pub = key.PrivateKey.PubKey;
            var uncompressed = pub.Decompress().ToBytes();
            var publicKeyNoPrefix = new byte[64];
            Array.Copy(uncompressed, 1, publicKeyNoPrefix, 0, 64);

            var hash = new Sha3Keccack().CalculateHash(publicKeyNoPrefix);
            var addressBytes = hash.Skip(hash.Length - 20).ToArray();
            return "0x" + BitConverter.ToString(addressBytes).Replace("-", "").ToLowerInvariant();
        }
        catch (Exception ex)
        {
            Logger.Warning($"Failed to derive address at index {index}: {ex.Message}");
            return null;
        }
    }

    private void OnCopyMnemonic(object sender, RoutedEventArgs e)
    {
        var mnemonic = RecoveredMnemonicBox.Text;
        if (string.IsNullOrWhiteSpace(mnemonic))
        {
            UpdateStatus("Nothing to copy. Recover a mnemonic first.", true);
            return;
        }

        Clipboard.SetText(mnemonic);
        UpdateStatus("Mnemonic copied to clipboard.", false);
    }

    private void UpdateStatus(string message, bool isError)
    {
        StatusText.Text = message;
        StatusText.Foreground = isError ? System.Windows.Media.Brushes.Tomato : new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(203, 213, 225));
    }

    private sealed record ShareSetMetadata(int TotalShares, int Threshold, int ClientShareCount, int SafekeepingShareCount, string Network, int ShareLength)
    {
        public string Description => $"{Threshold}-of-{TotalShares} ({Network})";

        public bool IsCompatibleWith(ShareFilePayload payload, int shareLength)
        {
            return payload.TotalShares == TotalShares
                   && payload.Threshold == Threshold
                   && payload.ClientShareCount == ClientShareCount
                   && payload.SafekeepingShareCount == SafekeepingShareCount
                   && shareLength == ShareLength
                   && string.Equals(payload.Network ?? string.Empty, Network, StringComparison.OrdinalIgnoreCase);
        }
    }

    private sealed class ShareViewModel
    {
        public ShareViewModel(string path, ShareFilePayload payload)
        {
            Path = path;
            Payload = payload;
        }

        public string Path { get; }
        public ShareFilePayload Payload { get; }

        public byte ShareId => Payload.ShareId;
        public string ShareValue => Payload.ShareValue ?? string.Empty;
        public string FileName => System.IO.Path.GetFileName(Path);
        public string Network => string.IsNullOrWhiteSpace(Payload.Network) ? "unknown" : Payload.Network;
        public string CreatedAtLocal => Payload.CreatedAtUtc.ToLocalTime().ToString("yyyy-MM-dd HH:mm");
        public string SharesDisplay => $"{Payload.Threshold}-of-{Payload.TotalShares}";
    }

    private sealed class ShareFilePayload
    {
        [JsonPropertyName("createdAtUtc")]
        public DateTimeOffset CreatedAtUtc { get; set; }

        [JsonPropertyName("network")]
        public string? Network { get; set; }

        [JsonPropertyName("totalShares")]
        public int TotalShares { get; set; }

        [JsonPropertyName("threshold")]
        public int Threshold { get; set; }

        [JsonPropertyName("clientShareCount")]
        public int ClientShareCount { get; set; }

        [JsonPropertyName("safekeepingShareCount")]
        public int SafekeepingShareCount { get; set; }

        [JsonPropertyName("shareId")]
        public byte ShareId { get; set; }

        [JsonPropertyName("shareValue")]
        public string? ShareValue { get; set; }
    }
}
