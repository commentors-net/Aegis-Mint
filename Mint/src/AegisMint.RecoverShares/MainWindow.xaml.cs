using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Windows;
using Microsoft.Win32;
using AegisMint.Core.Models;
using AegisMint.Core.Security;
using AegisMint.Core.Services;
using NBitcoin;
using Nethereum.Util;

namespace AegisMint.RecoverShares;

public partial class MainWindow : Window
{
    private readonly ObservableCollection<ShareViewModel> _shares = new();
    private readonly JsonSerializerOptions _jsonOptions = new(JsonSerializerDefaults.Web)
    {
        PropertyNameCaseInsensitive = true,
        ReadCommentHandling = JsonCommentHandling.Skip,
        AllowTrailingCommas = true
    };

    private readonly ShamirSecretSharingService _shamir = new();
    private ShareSetMetadata? _metadata;

    public MainWindow()
    {
        InitializeComponent();
        SharesList.ItemsSource = _shares;
        UpdateThresholdText();
        UpdateStatus("Load the recovery share files generated by Aegis Mint.", false);
    }

    private void OnBrowseClick(object sender, RoutedEventArgs e)
    {
        var dialog = new OpenFileDialog
        {
            Title = "Select recovery share files",
            Filter = $"Aegis share files (*{ShareFileCrypto.FileExtension})|*{ShareFileCrypto.FileExtension}|All files (*.*)|*.*",
            Multiselect = true,
            CheckFileExists = true
        };

        if (dialog.ShowDialog() == true)
        {
            LoadShares(dialog.FileNames);
        }
    }

    private void OnClearClick(object sender, RoutedEventArgs e)
    {
        _shares.Clear();
        _metadata = null;
        RecoveredMnemonicBox.Clear();
        PrimaryAddressText.Text = "–";
        SecondaryAddressText.Text = "–";
        MnemonicValidationText.Text = string.Empty;
        UpdateThresholdText();
        UpdateStatus("Cleared loaded shares.", false);
    }

    private void LoadShares(IEnumerable<string> files)
    {
        var added = 0;
        var replaced = 0;
        var errors = new List<string>();

        foreach (var file in files.Distinct(StringComparer.OrdinalIgnoreCase))
        {
            try
            {
                var payload = ParseShareFile(file, out var shareLength);

                if (_metadata is null)
                {
                    _metadata = new ShareSetMetadata(
                        payload.TotalShares,
                        payload.Threshold,
                        payload.ClientShareCount,
                        payload.SafekeepingShareCount,
                        payload.Network ?? string.Empty,
                        shareLength);
                }
                else if (!_metadata.IsCompatibleWith(payload, shareLength))
                {
                    errors.Add($"{Path.GetFileName(file)}: metadata mismatch. Expected {_metadata.Description}.");
                    continue;
                }

                // Parse share ID from the share field (format: "index-hexvalue")
                var shareParts = payload.Share?.Split('-', 2);
                var shareId = shareParts != null && shareParts.Length == 2 ? byte.Parse(shareParts[0]) : (byte)0;
                
                var existing = _shares.FirstOrDefault(s => s.ShareId == shareId);
                if (existing is not null)
                {
                    _shares.Remove(existing);
                    replaced++;
                }

                _shares.Add(new ShareViewModel(file, payload));
                added++;
            }
            catch (Exception ex)
            {
                errors.Add($"{Path.GetFileName(file)}: {ex.Message}");
                Logger.Warning($"Failed to load share file {file}: {ex.Message}");
            }
        }

        UpdateThresholdText();

        if (errors.Count > 0)
        {
            UpdateStatus($"Loaded {added} share(s). {replaced} replaced. Issues: {string.Join("; ", errors)}", true);
        }
        else if (added == 0 && replaced == 0)
        {
            UpdateStatus("No new shares were loaded.", true);
        }
        else
        {
            UpdateStatus($"Loaded {added} share(s){(replaced > 0 ? $" and replaced {replaced}" : string.Empty)}.", false);
        }
    }

    private ShareFilePayload ParseShareFile(string path, out int shareLength)
    {
        var encryptedPayload = File.ReadAllText(path);
        var json = ShareFileCrypto.DecryptSharePayload(encryptedPayload);
        var payload = JsonSerializer.Deserialize<ShareFilePayload>(json, _jsonOptions)
            ?? throw new InvalidOperationException("File did not contain a share payload.");

        if (payload.Threshold <= 0 || payload.TotalShares <= 0 || payload.Threshold > payload.TotalShares)
        {
            throw new InvalidOperationException("Invalid threshold/total share values.");
        }

        if (string.IsNullOrWhiteSpace(payload.Share))
        {
            throw new InvalidOperationException("Missing share data.");
        }

        if (string.IsNullOrWhiteSpace(payload.EncryptedMnemonic))
        {
            throw new InvalidOperationException("Missing encrypted mnemonic.");
        }

        if (string.IsNullOrWhiteSpace(payload.Iv))
        {
            throw new InvalidOperationException("Missing IV.");
        }

        // Parse share to get length (format: "index-hexvalue")
        var parts = payload.Share.Split('-', 2);
        if (parts.Length != 2)
        {
            throw new InvalidOperationException("Invalid share format.");
        }
        shareLength = parts[1].Length;

        return payload;
    }

    private void UpdateThresholdText()
    {
        if (_metadata is null)
        {
            ThresholdText.Text = "Threshold: waiting for shares.";
            RecoverButton.IsEnabled = false;
            return;
        }

        var ready = _shares.Count >= _metadata.Threshold;
        ThresholdText.Text = $"{_metadata.Threshold}-of-{_metadata.TotalShares} needed. Loaded {_shares.Count}.";
        RecoverButton.IsEnabled = ready;
    }

    private void OnRecoverClick(object sender, RoutedEventArgs e)
    {
        try
        {
            if (_metadata is null)
            {
                UpdateStatus("Load at least one share before recovering.", true);
                return;
            }

            if (_shares.Count < _metadata.Threshold)
            {
                UpdateStatus($"Need at least {_metadata.Threshold} shares; only {_shares.Count} loaded.", true);
                return;
            }

            // Get encrypted mnemonic and IV from first share (all should have same values)
            var firstPayload = _shares[0].Payload;
            if (string.IsNullOrWhiteSpace(firstPayload.EncryptedMnemonic) || string.IsNullOrWhiteSpace(firstPayload.Iv))
            {
                UpdateStatus("Shares are missing encrypted mnemonic or IV.", true);
                return;
            }

            // Parse share format: "index-hexvalue"
            var parsedShares = _shares
                .Take(_metadata.Threshold)
                .Select(s => {
                    var parts = s.Payload.Share?.Split('-', 2);
                    if (parts == null || parts.Length != 2)
                        throw new InvalidOperationException($"Invalid share format: {s.Payload.Share}");
                    return new ShamirShare(byte.Parse(parts[0]), parts[1]);
                })
                .ToArray();

            // Reconstruct encryption key from shares
            var keyHexBytes = _shamir.Combine(parsedShares, _metadata.Threshold);
            var keyHex = Encoding.UTF8.GetString(keyHexBytes).Trim();
            
            // Convert hex string to bytes
            var encryptionKey = Enumerable.Range(0, keyHex.Length)
                .Where(x => x % 2 == 0)
                .Select(x => Convert.ToByte(keyHex.Substring(x, 2), 16))
                .ToArray();

            // Decrypt the mnemonic
            var mnemonic = DecryptMnemonicWithKey(firstPayload.EncryptedMnemonic, firstPayload.Iv, encryptionKey);
            var normalizedMnemonic = string.Join(" ", mnemonic.Split(' ', StringSplitOptions.RemoveEmptyEntries));

            RecoveredMnemonicBox.Text = normalizedMnemonic;

            var validation = ValidateMnemonic(normalizedMnemonic);
            MnemonicValidationText.Text = validation;

            var primary = TryDeriveAddress(normalizedMnemonic, 0);
            var secondary = TryDeriveAddress(normalizedMnemonic, 1);
            PrimaryAddressText.Text = primary ?? "Unable to derive address";
            SecondaryAddressText.Text = secondary ?? "Unable to derive address";

            UpdateStatus($"Mnemonic recovered using {_metadata.Threshold} of {_metadata.TotalShares} shares.", false);
        }
        catch (Exception ex)
        {
            Logger.Error("Failed to recover mnemonic", ex);
            UpdateStatus($"Recovery failed: {ex.Message}", true);
            MessageBox.Show(this, $"Recovery failed: {ex.Message}", "Recovery error", MessageBoxButton.OK, MessageBoxImage.Error);
        }
    }

    private string ValidateMnemonic(string mnemonic)
    {
        if (string.IsNullOrWhiteSpace(mnemonic))
        {
            return "No mnemonic recovered.";
        }

        var words = mnemonic.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (words.Length is not (12 or 24))
        {
            return $"Warning: expected 12 or 24 words; found {words.Length}.";
        }

        try
        {
            _ = new Mnemonic(mnemonic, Wordlist.English);
            return $"Mnemonic is valid ({words.Length} words).";
        }
        catch (Exception ex)
        {
            Logger.Warning($"Recovered mnemonic failed validation: {ex.Message}");
            return "Warning: mnemonic failed BIP39 validation.";
        }
    }

    private string? TryDeriveAddress(string mnemonic, int index)
    {
        try
        {
            var mn = new Mnemonic(mnemonic, Wordlist.English);
            var seed = mn.DeriveExtKey();
            var path = new KeyPath($"m/44'/60'/0'/0/{index}");
            var key = seed.Derive(path);
            var pub = key.PrivateKey.PubKey;
            var uncompressed = pub.Decompress().ToBytes();
            var publicKeyNoPrefix = new byte[64];
            Array.Copy(uncompressed, 1, publicKeyNoPrefix, 0, 64);

            var hash = new Sha3Keccack().CalculateHash(publicKeyNoPrefix);
            var addressBytes = hash.Skip(hash.Length - 20).ToArray();
            return "0x" + BitConverter.ToString(addressBytes).Replace("-", "").ToLowerInvariant();
        }
        catch (Exception ex)
        {
            Logger.Warning($"Failed to derive address at index {index}: {ex.Message}");
            return null;
        }
    }

    private void OnCopyMnemonic(object sender, RoutedEventArgs e)
    {
        var mnemonic = RecoveredMnemonicBox.Text;
        if (string.IsNullOrWhiteSpace(mnemonic))
        {
            UpdateStatus("Nothing to copy. Recover a mnemonic first.", true);
            return;
        }

        Clipboard.SetText(mnemonic);
        UpdateStatus("Mnemonic copied to clipboard.", false);
    }

    private void UpdateStatus(string message, bool isError)
    {
        StatusText.Text = message;
        StatusText.Foreground = isError ? System.Windows.Media.Brushes.Tomato : new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(203, 213, 225));
    }

    // AES-256 decryption with explicit key and IV
    private string DecryptMnemonicWithKey(string encryptedMnemonicHex, string ivHex, byte[] key)
    {
        var encryptedBytes = Enumerable.Range(0, encryptedMnemonicHex.Length)
            .Where(x => x % 2 == 0)
            .Select(x => Convert.ToByte(encryptedMnemonicHex.Substring(x, 2), 16))
            .ToArray();
        
        var ivBytes = Enumerable.Range(0, ivHex.Length)
            .Where(x => x % 2 == 0)
            .Select(x => Convert.ToByte(ivHex.Substring(x, 2), 16))
            .ToArray();
        
        using var aes = System.Security.Cryptography.Aes.Create();
        aes.Key = key;
        aes.IV = ivBytes;
        
        using var decryptor = aes.CreateDecryptor();
        var decrypted = decryptor.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);
        
        return Encoding.UTF8.GetString(decrypted).Trim();
    }

    private sealed record ShareSetMetadata(int TotalShares, int Threshold, int ClientShareCount, int SafekeepingShareCount, string Network, int ShareLength)
    {
        public string Description => $"{Threshold}-of-{TotalShares} ({Network})";

        public bool IsCompatibleWith(ShareFilePayload payload, int shareLength)
        {
            return payload.TotalShares == TotalShares
                   && payload.Threshold == Threshold
                   && payload.ClientShareCount == ClientShareCount
                   && payload.SafekeepingShareCount == SafekeepingShareCount
                   && shareLength == ShareLength
                   && string.Equals(payload.Network ?? string.Empty, Network, StringComparison.OrdinalIgnoreCase);
        }
    }

    private sealed class ShareViewModel
    {
        public ShareViewModel(string path, ShareFilePayload payload)
        {
            Path = path;
            Payload = payload;
        }

        public string Path { get; }
        public ShareFilePayload Payload { get; }

        public byte ShareId {
            get {
                var parts = Payload.Share?.Split('-', 2);
                return parts != null && parts.Length == 2 ? byte.Parse(parts[0]) : (byte)0;
            }
        }
        public string ShareValue => Payload.Share ?? string.Empty;
        public string FileName => System.IO.Path.GetFileName(Path);
        public string Network => string.IsNullOrWhiteSpace(Payload.Network) ? "unknown" : Payload.Network;
        public string CreatedAtLocal => Payload.CreatedAtUtc.ToLocalTime().ToString("yyyy-MM-dd HH:mm");
        public string SharesDisplay => $"{Payload.Threshold}-of-{Payload.TotalShares}";
    }

    private sealed class ShareFilePayload
    {
        [JsonPropertyName("createdAtUtc")]
        public DateTimeOffset CreatedAtUtc { get; set; }

        [JsonPropertyName("network")]
        public string? Network { get; set; }

        [JsonPropertyName("totalShares")]
        public int TotalShares { get; set; }

        [JsonPropertyName("threshold")]
        public int Threshold { get; set; }

        [JsonPropertyName("clientShareCount")]
        public int ClientShareCount { get; set; }

        [JsonPropertyName("safekeepingShareCount")]
        public int SafekeepingShareCount { get; set; }

        [JsonPropertyName("share")]
        public string? Share { get; set; }

        [JsonPropertyName("encryptedMnemonic")]
        public string? EncryptedMnemonic { get; set; }

        [JsonPropertyName("iv")]
        public string? Iv { get; set; }

        [JsonPropertyName("encryptionVersion")]
        public int EncryptionVersion { get; set; }

        [JsonPropertyName("tokenAddress")]
        public string? TokenAddress { get; set; }
    }
}
