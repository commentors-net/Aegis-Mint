using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using System.Windows;
using Microsoft.Win32;
using AegisMint.Core.Models;
using AegisMint.Core.Security;
using AegisMint.Core.Services;
using NBitcoin;
using Nethereum.Util;
using WinForms = System.Windows.Forms;

namespace AegisMint.ShareManager;

public partial class MainWindow : Window
{
    private readonly ObservableCollection<ShareViewModel> _shares = new();
    private readonly JsonSerializerOptions _jsonOptions = new(JsonSerializerDefaults.Web)
    {
        PropertyNameCaseInsensitive = true,
        ReadCommentHandling = JsonCommentHandling.Skip,
        AllowTrailingCommas = true
    };

    private readonly ShamirSecretSharingService _shamir = new();
    private ShareSetMetadata? _metadata;
    private readonly VaultManager _vaultManager = new();
    private readonly DesktopAuthenticationService _authService;
    private bool _desktopRegistered;

    public MainWindow()
    {
        _authService = new DesktopAuthenticationService(_vaultManager, "ShareManager");
        InitializeComponent();
        SharesList.ItemsSource = _shares;
        UpdateThresholdText();
        UpdateStatus("Load the recovery share files generated by Aegis Mint.", false);
    }

    private void OnBrowseClick(object sender, RoutedEventArgs e)
    {
        var dialog = new Microsoft.Win32.OpenFileDialog
        {
            Title = "Select recovery share files",
            Filter = $"Aegis share files (*{ShareFileCrypto.FileExtension})|*{ShareFileCrypto.FileExtension}|All files (*.*)|*.*",
            Multiselect = true,
            CheckFileExists = true
        };

        if (dialog.ShowDialog() == true)
        {
            LoadShares(dialog.FileNames);
        }
    }

    private string RecoverMnemonic()
    {
        if (_metadata is null)
        {
            throw new InvalidOperationException("Load at least one share before recovering.");
        }

        if (_shares.Count < _metadata.Threshold)
        {
            throw new InvalidOperationException($"Need at least {_metadata.Threshold} shares; only {_shares.Count} loaded.");
        }

        var firstPayload = _shares[0].Payload;
        if (string.IsNullOrWhiteSpace(firstPayload.EncryptedMnemonic) || string.IsNullOrWhiteSpace(firstPayload.Iv))
        {
            throw new InvalidOperationException("Shares are missing encrypted mnemonic or IV.");
        }

        var parsedShares = _shares
            .Take(_metadata.Threshold)
            .Select(s =>
            {
                var parts = s.Payload.Share?.Split('-', 2);
                if (parts == null || parts.Length != 2)
                {
                    throw new InvalidOperationException($"Invalid share format: {s.Payload.Share}");
                }

                return new ShamirShare(byte.Parse(parts[0]), parts[1]);
            })
            .ToArray();

        var keyHexBytes = _shamir.Combine(parsedShares, _metadata.Threshold);
        var keyHex = Encoding.UTF8.GetString(keyHexBytes).Trim();

        var encryptionKey = Enumerable.Range(0, keyHex.Length)
            .Where(x => x % 2 == 0)
            .Select(x => Convert.ToByte(keyHex.Substring(x, 2), 16))
            .ToArray();

        var mnemonic = DecryptMnemonicWithKey(firstPayload.EncryptedMnemonic, firstPayload.Iv, encryptionKey);
        return string.Join(" ", mnemonic.Split(' ', StringSplitOptions.RemoveEmptyEntries));
    }

    private void OnClearClick(object sender, RoutedEventArgs e)
    {
        _shares.Clear();
        _metadata = null;
        RecoveredMnemonicBox.Clear();
        PrimaryAddressText.Text = "â€“";
        SecondaryAddressText.Text = "â€“";
        MnemonicValidationText.Text = string.Empty;
        TokenNameBox.Text = string.Empty;
        TokenAddressBox.Text = string.Empty;
        DeploymentIdBox.Text = string.Empty;
        NewTotalSharesBox.Text = string.Empty;
        NewThresholdBox.Text = string.Empty;
        OutputFolderBox.Text = string.Empty;
        UpdateThresholdText();
        UpdateStatus("Cleared loaded shares.", false);
    }

    private void LoadShares(IEnumerable<string> files)
    {
        var added = 0;
        var replaced = 0;
        var errors = new List<string>();

        foreach (var file in files.Distinct(StringComparer.OrdinalIgnoreCase))
        {
            try
            {
                var payload = ParseShareFile(file, out var shareLength);

                if (_metadata is null)
                {
                    _metadata = new ShareSetMetadata(
                        payload.TotalShares,
                        payload.Threshold,
                        payload.ClientShareCount,
                        payload.SafekeepingShareCount,
                        payload.Network ?? string.Empty,
                        payload.TokenAddress,
                        shareLength);
                }
                else if (!_metadata.IsCompatibleWith(payload, shareLength))
                {
                    errors.Add($"{Path.GetFileName(file)}: metadata mismatch. Expected {_metadata.Description}.");
                    continue;
                }

                // Parse share ID from the share field (format: "index-hexvalue")
                var shareParts = payload.Share?.Split('-', 2);
                var shareId = shareParts != null && shareParts.Length == 2 ? byte.Parse(shareParts[0]) : (byte)0;
                
                var existing = _shares.FirstOrDefault(s => s.ShareId == shareId);
                if (existing is not null)
                {
                    _shares.Remove(existing);
                    replaced++;
                }

                _shares.Add(new ShareViewModel(file, payload));
                added++;

                if (string.IsNullOrWhiteSpace(TokenNameBox.Text))
                {
                    var inferred = TryExtractTokenNameFromFileName(file);
                    if (!string.IsNullOrWhiteSpace(inferred))
                    {
                        TokenNameBox.Text = inferred;
                    }
                }

                if (string.IsNullOrWhiteSpace(TokenAddressBox.Text) && !string.IsNullOrWhiteSpace(payload.TokenAddress))
                {
                    TokenAddressBox.Text = payload.TokenAddress;
                }

                if (string.IsNullOrWhiteSpace(OutputFolderBox.Text))
                {
                    OutputFolderBox.Text = Path.GetDirectoryName(file) ?? string.Empty;
                }

                if (string.IsNullOrWhiteSpace(NewTotalSharesBox.Text))
                {
                    NewTotalSharesBox.Text = payload.TotalShares.ToString(CultureInfo.InvariantCulture);
                }

                if (string.IsNullOrWhiteSpace(NewThresholdBox.Text))
                {
                    NewThresholdBox.Text = payload.Threshold.ToString(CultureInfo.InvariantCulture);
                }
            }
            catch (Exception ex)
            {
                errors.Add($"{Path.GetFileName(file)}: {ex.Message}");
                Logger.Warning($"Failed to load share file {file}: {ex.Message}");
            }
        }

        UpdateThresholdText();

        if (errors.Count > 0)
        {
            UpdateStatus($"Loaded {added} share(s). {replaced} replaced. Issues: {string.Join("; ", errors)}", true);
        }
        else if (added == 0 && replaced == 0)
        {
            UpdateStatus("No new shares were loaded.", true);
        }
        else
        {
            UpdateStatus($"Loaded {added} share(s){(replaced > 0 ? $" and replaced {replaced}" : string.Empty)}.", false);
        }
    }

    private ShareFilePayload ParseShareFile(string path, out int shareLength)
    {
        var encryptedPayload = File.ReadAllText(path);
        var json = ShareFileCrypto.DecryptSharePayload(encryptedPayload);
        var payload = JsonSerializer.Deserialize<ShareFilePayload>(json, _jsonOptions)
            ?? throw new InvalidOperationException("File did not contain a share payload.");

        if (payload.Threshold <= 0 || payload.TotalShares <= 0 || payload.Threshold > payload.TotalShares)
        {
            throw new InvalidOperationException("Invalid threshold/total share values.");
        }

        if (string.IsNullOrWhiteSpace(payload.Share))
        {
            throw new InvalidOperationException("Missing share data.");
        }

        if (string.IsNullOrWhiteSpace(payload.EncryptedMnemonic))
        {
            throw new InvalidOperationException("Missing encrypted mnemonic.");
        }

        if (string.IsNullOrWhiteSpace(payload.Iv))
        {
            throw new InvalidOperationException("Missing IV.");
        }

        // Parse share to get length (format: "index-hexvalue")
        var parts = payload.Share.Split('-', 2);
        if (parts.Length != 2)
        {
            throw new InvalidOperationException("Invalid share format.");
        }
        shareLength = parts[1].Length;

        return payload;
    }

    private void UpdateThresholdText()
    {
        if (_metadata is null)
        {
            ThresholdText.Text = "Threshold: waiting for shares.";
            RecoverButton.IsEnabled = false;
            ReconfigureButton.IsEnabled = false;
            return;
        }

        var ready = _shares.Count >= _metadata.Threshold;
        ThresholdText.Text = $"{_metadata.Threshold}-of-{_metadata.TotalShares} needed. Loaded {_shares.Count}.";
        RecoverButton.IsEnabled = ready;
        ReconfigureButton.IsEnabled = ready;
    }

    private void OnRecoverClick(object sender, RoutedEventArgs e)
    {
        try
        {
            var normalizedMnemonic = RecoverMnemonic();

            RecoveredMnemonicBox.Text = normalizedMnemonic;

            var validation = ValidateMnemonic(normalizedMnemonic);
            MnemonicValidationText.Text = validation;

            var primary = TryDeriveAddress(normalizedMnemonic, 0);
            var secondary = TryDeriveAddress(normalizedMnemonic, 1);
            PrimaryAddressText.Text = primary ?? "Unable to derive address";
            SecondaryAddressText.Text = secondary ?? "Unable to derive address";

            UpdateStatus($"Mnemonic recovered using {_metadata.Threshold} of {_metadata.TotalShares} shares.", false);
        }
        catch (Exception ex)
        {
            Logger.Error("Failed to recover mnemonic", ex);
            UpdateStatus($"Recovery failed: {ex.Message}", true);
            System.Windows.MessageBox.Show(this, $"Recovery failed: {ex.Message}", "Recovery error", System.Windows.MessageBoxButton.OK, System.Windows.MessageBoxImage.Error);
        }
    }

    private string ValidateMnemonic(string mnemonic)
    {
        if (string.IsNullOrWhiteSpace(mnemonic))
        {
            return "No mnemonic recovered.";
        }

        var words = mnemonic.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (words.Length is not (12 or 24))
        {
            return $"Warning: expected 12 or 24 words; found {words.Length}.";
        }

        try
        {
            _ = new Mnemonic(mnemonic, Wordlist.English);
            return $"Mnemonic is valid ({words.Length} words).";
        }
        catch (Exception ex)
        {
            Logger.Warning($"Recovered mnemonic failed validation: {ex.Message}");
            return "Warning: mnemonic failed BIP39 validation.";
        }
    }

    private string? TryDeriveAddress(string mnemonic, int index)
    {
        try
        {
            var mn = new Mnemonic(mnemonic, Wordlist.English);
            var seed = mn.DeriveExtKey();
            var path = new KeyPath($"m/44'/60'/0'/0/{index}");
            var key = seed.Derive(path);
            var pub = key.PrivateKey.PubKey;
            var uncompressed = pub.Decompress().ToBytes();
            var publicKeyNoPrefix = new byte[64];
            Array.Copy(uncompressed, 1, publicKeyNoPrefix, 0, 64);

            var hash = new Sha3Keccack().CalculateHash(publicKeyNoPrefix);
            var addressBytes = hash.Skip(hash.Length - 20).ToArray();
            return "0x" + BitConverter.ToString(addressBytes).Replace("-", "").ToLowerInvariant();
        }
        catch (Exception ex)
        {
            Logger.Warning($"Failed to derive address at index {index}: {ex.Message}");
            return null;
        }
    }

    private void OnCopyMnemonic(object sender, RoutedEventArgs e)
    {
        var mnemonic = RecoveredMnemonicBox.Text;
        if (string.IsNullOrWhiteSpace(mnemonic))
        {
            UpdateStatus("Nothing to copy. Recover a mnemonic first.", true);
            return;
        }

        System.Windows.Clipboard.SetText(mnemonic);
        UpdateStatus("Mnemonic copied to clipboard.", false);
    }

    private async void OnLookupDeploymentClick(object sender, RoutedEventArgs e)
    {
        var tokenAddress = TokenAddressBox.Text.Trim();
        if (string.IsNullOrWhiteSpace(tokenAddress))
        {
            UpdateStatus("Token address is required to look up deployment ID.", true);
            return;
        }

        try
        {
            var deploymentId = await GetTokenDeploymentIdAsync(tokenAddress);
            if (string.IsNullOrWhiteSpace(deploymentId))
            {
                UpdateStatus("No deployment found for the provided token address.", true);
                return;
            }

            DeploymentIdBox.Text = deploymentId;
            UpdateStatus("Deployment ID loaded from backend.", false);
        }
        catch (Exception ex)
        {
            Logger.Error("Failed to look up deployment ID", ex);
            UpdateStatus($"Lookup failed: {ex.Message}", true);
        }
    }

    private void OnBrowseOutputClick(object sender, RoutedEventArgs e)
    {
        using var dialog = new WinForms.FolderBrowserDialog
        {
            Description = "Select output folder for new shares",
            UseDescriptionForTitle = true
        };

        if (Directory.Exists(OutputFolderBox.Text))
        {
            dialog.SelectedPath = OutputFolderBox.Text;
        }

        if (dialog.ShowDialog() == WinForms.DialogResult.OK)
        {
            OutputFolderBox.Text = dialog.SelectedPath;
        }
    }

    private async void OnReconfigureClick(object sender, RoutedEventArgs e)
    {
        try
        {
            if (_metadata is null)
            {
                UpdateStatus("Load the existing shares before reconfiguring.", true);
                return;
            }

            if (_shares.Count < _metadata.Threshold)
            {
                UpdateStatus($"Need at least {_metadata.Threshold} shares; only {_shares.Count} loaded.", true);
                return;
            }

            if (!int.TryParse(NewTotalSharesBox.Text, NumberStyles.None, CultureInfo.InvariantCulture, out var newTotal) || newTotal < 2)
            {
                UpdateStatus("Enter a valid new total share count (>= 2).", true);
                return;
            }

            if (!int.TryParse(NewThresholdBox.Text, NumberStyles.None, CultureInfo.InvariantCulture, out var newThreshold) || newThreshold < 2)
            {
                UpdateStatus("Enter a valid new threshold (>= 2).", true);
                return;
            }

            if (newThreshold > newTotal)
            {
                UpdateStatus("Threshold cannot exceed total shares.", true);
                return;
            }

            if (newTotal - newThreshold < 1)
            {
                UpdateStatus("Total shares must exceed threshold to keep at least one distributable share.", true);
                return;
            }

            if (newTotal > 99 || newThreshold > 99)
            {
                UpdateStatus("Share naming supports up to 99 total/threshold shares.", true);
                return;
            }

            var tokenName = TokenNameBox.Text.Trim();
            if (string.IsNullOrWhiteSpace(tokenName))
            {
                UpdateStatus("Token name is required for new share filenames.", true);
                return;
            }

            var outputDir = OutputFolderBox.Text.Trim();
            if (string.IsNullOrWhiteSpace(outputDir))
            {
                UpdateStatus("Select an output folder for the new shares.", true);
                return;
            }

            Directory.CreateDirectory(outputDir);

            var deploymentId = DeploymentIdBox.Text.Trim();
            if (string.IsNullOrWhiteSpace(deploymentId))
            {
                UpdateStatus("Deployment ID is required to update the backend.", true);
                return;
            }

            var mnemonic = RecoverMnemonic();
            var tokenAddress = TokenAddressBox.Text.Trim();
            var generatedShares = GenerateNewShares(
                mnemonic,
                tokenName,
                newTotal,
                newThreshold,
                _metadata.Network,
                string.IsNullOrWhiteSpace(tokenAddress) ? null : tokenAddress);

            foreach (var share in generatedShares)
            {
                var path = Path.Combine(outputDir, share.FileName);
                File.WriteAllText(path, share.EncryptedContent);
            }

            await EnsureDesktopRegistrationAsync();
            await UploadShareRotationAsync(deploymentId, generatedShares, newTotal, newThreshold, outputDir);

            UpdateStatus("New shares generated and uploaded. Old shares are inactive in backend.", false);
        }
        catch (Exception ex)
        {
            Logger.Error("Failed to reconfigure shares", ex);
            UpdateStatus($"Reconfiguration failed: {ex.Message}", true);
            System.Windows.MessageBox.Show(this, $"Reconfiguration failed: {ex.Message}", "Share reconfiguration error", System.Windows.MessageBoxButton.OK, System.Windows.MessageBoxImage.Error);
        }
    }

    private void UpdateStatus(string message, bool isError)
    {
        StatusText.Text = message;
        StatusText.Foreground = isError ? System.Windows.Media.Brushes.Tomato : new System.Windows.Media.SolidColorBrush(System.Windows.Media.Color.FromRgb(203, 213, 225));
    }

    private async Task EnsureDesktopRegistrationAsync()
    {
        if (_desktopRegistered)
        {
            return;
        }

        var version = typeof(MainWindow).Assembly.GetName().Version?.ToString() ?? "0.0.0";
        await _authService.RegisterAsync(
            Environment.MachineName,
            version,
            Environment.UserName,
            "Share Manager",
            "ShareManager");
        _desktopRegistered = true;
    }

    private async Task<string?> GetTokenDeploymentIdAsync(string contractAddress)
    {
        var apiBaseUrl = _vaultManager.GetApiBaseUrl();
        using var httpClient = new HttpClient { Timeout = TimeSpan.FromSeconds(10) };
        var endpoint = $"/token-deployments/?contract_address={Uri.EscapeDataString(contractAddress)}";
        var fullUrl = apiBaseUrl.TrimEnd('/') + endpoint;

        var response = await httpClient.GetAsync(fullUrl);
        if (!response.IsSuccessStatusCode)
        {
            Logger.Warning($"Failed to query token deployments. Status: {response.StatusCode}");
            return null;
        }

        var responseBody = await response.Content.ReadAsStringAsync();
        using var jsonDoc = JsonDocument.Parse(responseBody);

        if (jsonDoc.RootElement.ValueKind == JsonValueKind.Array && jsonDoc.RootElement.GetArrayLength() > 0)
        {
            var firstDeployment = jsonDoc.RootElement[0];
            if (firstDeployment.TryGetProperty("id", out var idElement))
            {
                return idElement.GetString();
            }
        }

        return null;
    }

    private List<GeneratedShareFile> GenerateNewShares(
        string mnemonic,
        string tokenName,
        int totalShares,
        int threshold,
        string network,
        string? tokenAddress)
    {
        var keyBytes = RandomNumberGenerator.GetBytes(32);
        var keyHex = Convert.ToHexString(keyBytes);

        using var aes = Aes.Create();
        aes.Key = keyBytes;
        aes.GenerateIV();

        using var encryptor = aes.CreateEncryptor();
        var mnemonicBytes = Encoding.UTF8.GetBytes(mnemonic);
        var encryptedBytes = encryptor.TransformFinalBlock(mnemonicBytes, 0, mnemonicBytes.Length);
        var encryptedMnemonicHex = Convert.ToHexString(encryptedBytes);
        var ivHex = Convert.ToHexString(aes.IV);

        var shamir = new ShamirSecretSharingService();
        var shareSeed = Encoding.UTF8.GetBytes(keyHex);
        var shares = shamir.Split(shareSeed, threshold, totalShares);

        var createdAt = DateTimeOffset.UtcNow;
        var payloadOptions = new JsonSerializerOptions { WriteIndented = true };
        var result = new List<GeneratedShareFile>(shares.Count);

        foreach (var share in shares)
        {
            var payload = new
            {
                createdAtUtc = createdAt,
                network,
                totalShares,
                threshold,
                clientShareCount = totalShares - threshold,
                safekeepingShareCount = threshold,
                share = $"{share.Id}-{share.Value}",
                encryptedMnemonic = encryptedMnemonicHex,
                iv = ivHex,
                encryptionVersion = 1,
                tokenAddress = string.IsNullOrWhiteSpace(tokenAddress) ? null : tokenAddress
            };

            var json = JsonSerializer.Serialize(payload, payloadOptions);
            var encryptedPayload = ShareFileCrypto.EncryptShareJson(json);
            var fileName = ShareFileCrypto.BuildFileName(createdAt, tokenName, share.Id, totalShares);

            result.Add(new GeneratedShareFile(share.Id, fileName, encryptedPayload));
        }

        return result;
    }

    private async Task UploadShareRotationAsync(
        string deploymentId,
        List<GeneratedShareFile> shares,
        int totalShares,
        int threshold,
        string outputDir)
    {
        var shareItems = shares.Select(s => new
        {
            share_number = s.ShareNumber,
            file_name = s.FileName,
            encrypted_content = s.EncryptedContent,
            encryption_key_id = ShareFileCrypto.EncryptionKeyId
        }).ToList();

        var payload = new
        {
            token_deployment_id = deploymentId,
            replace_existing = true,
            total_shares = totalShares,
            gov_threshold = threshold,
            gov_shares = totalShares - threshold,
            client_share_count = totalShares - threshold,
            safekeeping_share_count = threshold,
            shares_path = outputDir,
            shares = shareItems
        };

        var response = await _authService.PostAuthenticatedAsync<ShareFilesBulkResponse>("/share-files/bulk", payload);
        Logger.Info($"Share rotation upload complete. Created {response.CreatedCount} shares.");
    }

    private static string? TryExtractTokenNameFromFileName(string path)
    {
        var baseName = Path.GetFileNameWithoutExtension(path);
        if (string.IsNullOrWhiteSpace(baseName) || baseName.Length <= 10)
        {
            return null;
        }

        return baseName.Substring(6, baseName.Length - 10);
    }

    // AES-256 decryption with explicit key and IV
    private string DecryptMnemonicWithKey(string encryptedMnemonicHex, string ivHex, byte[] key)
    {
        var encryptedBytes = Enumerable.Range(0, encryptedMnemonicHex.Length)
            .Where(x => x % 2 == 0)
            .Select(x => Convert.ToByte(encryptedMnemonicHex.Substring(x, 2), 16))
            .ToArray();
        
        var ivBytes = Enumerable.Range(0, ivHex.Length)
            .Where(x => x % 2 == 0)
            .Select(x => Convert.ToByte(ivHex.Substring(x, 2), 16))
            .ToArray();
        
        using var aes = System.Security.Cryptography.Aes.Create();
        aes.Key = key;
        aes.IV = ivBytes;
        
        using var decryptor = aes.CreateDecryptor();
        var decrypted = decryptor.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);
        
        return Encoding.UTF8.GetString(decrypted).Trim();
    }

    private sealed record ShareSetMetadata(
        int TotalShares,
        int Threshold,
        int ClientShareCount,
        int SafekeepingShareCount,
        string Network,
        string? TokenAddress,
        int ShareLength)
    {
        public string Description => $"{Threshold}-of-{TotalShares} ({Network})";

        public bool IsCompatibleWith(ShareFilePayload payload, int shareLength)
        {
            return payload.TotalShares == TotalShares
                   && payload.Threshold == Threshold
                   && payload.ClientShareCount == ClientShareCount
                   && payload.SafekeepingShareCount == SafekeepingShareCount
                   && shareLength == ShareLength
                   && string.Equals(payload.Network ?? string.Empty, Network, StringComparison.OrdinalIgnoreCase)
                   && string.Equals(payload.TokenAddress ?? string.Empty, TokenAddress ?? string.Empty, StringComparison.OrdinalIgnoreCase);
        }
    }

    private sealed class ShareViewModel
    {
        public ShareViewModel(string path, ShareFilePayload payload)
        {
            Path = path;
            Payload = payload;
        }

        public string Path { get; }
        public ShareFilePayload Payload { get; }

        public byte ShareId {
            get {
                var parts = Payload.Share?.Split('-', 2);
                return parts != null && parts.Length == 2 ? byte.Parse(parts[0]) : (byte)0;
            }
        }
        public string ShareValue => Payload.Share ?? string.Empty;
        public string FileName => System.IO.Path.GetFileName(Path);
        public string Network => string.IsNullOrWhiteSpace(Payload.Network) ? "unknown" : Payload.Network;
        public string CreatedAtLocal => Payload.CreatedAtUtc.ToLocalTime().ToString("yyyy-MM-dd HH:mm");
        public string SharesDisplay => $"{Payload.Threshold}-of-{Payload.TotalShares}";
    }

    private sealed record GeneratedShareFile(int ShareNumber, string FileName, string EncryptedContent);

    private sealed class ShareFilesBulkResponse
    {
        [JsonPropertyName("created_count")]
        public int CreatedCount { get; set; }
    }

    private sealed class ShareFilePayload
    {
        [JsonPropertyName("createdAtUtc")]
        public DateTimeOffset CreatedAtUtc { get; set; }

        [JsonPropertyName("network")]
        public string? Network { get; set; }

        [JsonPropertyName("totalShares")]
        public int TotalShares { get; set; }

        [JsonPropertyName("threshold")]
        public int Threshold { get; set; }

        [JsonPropertyName("clientShareCount")]
        public int ClientShareCount { get; set; }

        [JsonPropertyName("safekeepingShareCount")]
        public int SafekeepingShareCount { get; set; }

        [JsonPropertyName("share")]
        public string? Share { get; set; }

        [JsonPropertyName("encryptedMnemonic")]
        public string? EncryptedMnemonic { get; set; }

        [JsonPropertyName("iv")]
        public string? Iv { get; set; }

        [JsonPropertyName("encryptionVersion")]
        public int EncryptionVersion { get; set; }

        [JsonPropertyName("tokenAddress")]
        public string? TokenAddress { get; set; }
    }
}
